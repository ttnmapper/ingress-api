// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/gogo/protobuf/types"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = types.DynamicAny{}
)

// define the regex for a UUID once up-front
var _end_device_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// ValidateFields checks the field values on Session with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Session) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SessionFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "dev_addr":
			// no validation rules for DevAddr
		case "keys":

			if v, ok := interface{}(&m.SessionKeys).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SessionValidationError{
						field:  "keys",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "last_f_cnt_up":
			// no validation rules for LastFCntUp
		case "last_n_f_cnt_down":
			// no validation rules for LastNFCntDown
		case "last_a_f_cnt_down":
			// no validation rules for LastAFCntDown
		case "last_conf_f_cnt_down":
			// no validation rules for LastConfFCntDown
		case "started_at":

			if v, ok := interface{}(&m.StartedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SessionValidationError{
						field:  "started_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "queued_application_downlinks":

			for idx, item := range m.GetQueuedApplicationDownlinks() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return SessionValidationError{
							field:  fmt.Sprintf("queued_application_downlinks[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return SessionValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// SessionValidationError is the validation error returned by
// Session.ValidateFields if the designated constraints aren't met.
type SessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionValidationError) ErrorName() string { return "SessionValidationError" }

// Error satisfies the builtin error interface
func (e SessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionValidationError{}

// ValidateFields checks the field values on BoolValue with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *BoolValue) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = BoolValueFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "value":
			// no validation rules for Value
		default:
			return BoolValueValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// BoolValueValidationError is the validation error returned by
// BoolValue.ValidateFields if the designated constraints aren't met.
type BoolValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoolValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoolValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoolValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoolValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoolValueValidationError) ErrorName() string { return "BoolValueValidationError" }

// Error satisfies the builtin error interface
func (e BoolValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoolValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoolValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoolValueValidationError{}

// ValidateFields checks the field values on MACParameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACParameters) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACParametersFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "max_eirp":
			// no validation rules for MaxEIRP
		case "adr_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetADRDataRateIndex())]; !ok {
				return MACParametersValidationError{
					field:  "adr_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		case "adr_tx_power_index":

			if m.GetADRTxPowerIndex() > 15 {
				return MACParametersValidationError{
					field:  "adr_tx_power_index",
					reason: "value must be less than or equal to 15",
				}
			}

		case "adr_nb_trans":

			if m.GetADRNbTrans() > 15 {
				return MACParametersValidationError{
					field:  "adr_nb_trans",
					reason: "value must be less than or equal to 15",
				}
			}

		case "adr_ack_limit":
			// no validation rules for ADRAckLimit
		case "adr_ack_delay":
			// no validation rules for ADRAckDelay
		case "rx1_delay":

			if _, ok := RxDelay_name[int32(m.GetRx1Delay())]; !ok {
				return MACParametersValidationError{
					field:  "rx1_delay",
					reason: "value must be one of the defined enum values",
				}
			}

		case "rx1_data_rate_offset":

			if _, ok := DataRateOffset_name[int32(m.GetRx1DataRateOffset())]; !ok {
				return MACParametersValidationError{
					field:  "rx1_data_rate_offset",
					reason: "value must be one of the defined enum values",
				}
			}

		case "rx2_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetRx2DataRateIndex())]; !ok {
				return MACParametersValidationError{
					field:  "rx2_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		case "rx2_frequency":

			if m.GetRx2Frequency() < 100000 {
				return MACParametersValidationError{
					field:  "rx2_frequency",
					reason: "value must be greater than or equal to 100000",
				}
			}

		case "max_duty_cycle":

			if _, ok := AggregatedDutyCycle_name[int32(m.GetMaxDutyCycle())]; !ok {
				return MACParametersValidationError{
					field:  "max_duty_cycle",
					reason: "value must be one of the defined enum values",
				}
			}

		case "rejoin_time_periodicity":

			if _, ok := RejoinTimeExponent_name[int32(m.GetRejoinTimePeriodicity())]; !ok {
				return MACParametersValidationError{
					field:  "rejoin_time_periodicity",
					reason: "value must be one of the defined enum values",
				}
			}

		case "rejoin_count_periodicity":

			if _, ok := RejoinCountExponent_name[int32(m.GetRejoinCountPeriodicity())]; !ok {
				return MACParametersValidationError{
					field:  "rejoin_count_periodicity",
					reason: "value must be one of the defined enum values",
				}
			}

		case "ping_slot_frequency":

			if val := m.GetPingSlotFrequency(); val > 0 && val < 100000 {
				return MACParametersValidationError{
					field:  "ping_slot_frequency",
					reason: "value must be outside range (0, 100000)",
				}
			}

		case "ping_slot_data_rate_index":
			// no validation rules for PingSlotDataRateIndex
		case "beacon_frequency":

			if val := m.GetBeaconFrequency(); val > 0 && val < 100000 {
				return MACParametersValidationError{
					field:  "beacon_frequency",
					reason: "value must be outside range (0, 100000)",
				}
			}

		case "channels":

			if len(m.GetChannels()) < 1 {
				return MACParametersValidationError{
					field:  "channels",
					reason: "value must contain at least 1 item(s)",
				}
			}

			for idx, item := range m.GetChannels() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACParametersValidationError{
							field:  fmt.Sprintf("channels[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "uplink_dwell_time":

			if v, ok := interface{}(m.GetUplinkDwellTime()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACParametersValidationError{
						field:  "uplink_dwell_time",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "downlink_dwell_time":

			if v, ok := interface{}(m.GetDownlinkDwellTime()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACParametersValidationError{
						field:  "downlink_dwell_time",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "adr_ack_limit_exponent":

			if v, ok := interface{}(m.GetADRAckLimitExponent()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACParametersValidationError{
						field:  "adr_ack_limit_exponent",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "adr_ack_delay_exponent":

			if v, ok := interface{}(m.GetADRAckDelayExponent()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACParametersValidationError{
						field:  "adr_ack_delay_exponent",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "ping_slot_data_rate_index_value":

			if v, ok := interface{}(m.GetPingSlotDataRateIndexValue()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACParametersValidationError{
						field:  "ping_slot_data_rate_index_value",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return MACParametersValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACParametersValidationError is the validation error returned by
// MACParameters.ValidateFields if the designated constraints aren't met.
type MACParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACParametersValidationError) ErrorName() string { return "MACParametersValidationError" }

// Error satisfies the builtin error interface
func (e MACParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACParametersValidationError{}

// ValidateFields checks the field values on EndDeviceVersionIdentifiers with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *EndDeviceVersionIdentifiers) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceVersionIdentifiersFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "brand_id":

			if m.GetBrandID() != "" {

				if utf8.RuneCountInString(m.GetBrandID()) > 36 {
					return EndDeviceVersionIdentifiersValidationError{
						field:  "brand_id",
						reason: "value length must be at most 36 runes",
					}
				}

				if !_EndDeviceVersionIdentifiers_BrandID_Pattern.MatchString(m.GetBrandID()) {
					return EndDeviceVersionIdentifiersValidationError{
						field:  "brand_id",
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

			}

		case "model_id":

			if m.GetModelID() != "" {

				if utf8.RuneCountInString(m.GetModelID()) > 36 {
					return EndDeviceVersionIdentifiersValidationError{
						field:  "model_id",
						reason: "value length must be at most 36 runes",
					}
				}

				if !_EndDeviceVersionIdentifiers_ModelID_Pattern.MatchString(m.GetModelID()) {
					return EndDeviceVersionIdentifiersValidationError{
						field:  "model_id",
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

			}

		case "hardware_version":

			if utf8.RuneCountInString(m.GetHardwareVersion()) > 32 {
				return EndDeviceVersionIdentifiersValidationError{
					field:  "hardware_version",
					reason: "value length must be at most 32 runes",
				}
			}

		case "firmware_version":

			if utf8.RuneCountInString(m.GetFirmwareVersion()) > 32 {
				return EndDeviceVersionIdentifiersValidationError{
					field:  "firmware_version",
					reason: "value length must be at most 32 runes",
				}
			}

		case "band_id":

			if utf8.RuneCountInString(m.GetBandID()) > 32 {
				return EndDeviceVersionIdentifiersValidationError{
					field:  "band_id",
					reason: "value length must be at most 32 runes",
				}
			}

		default:
			return EndDeviceVersionIdentifiersValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceVersionIdentifiersValidationError is the validation error returned
// by EndDeviceVersionIdentifiers.ValidateFields if the designated constraints
// aren't met.
type EndDeviceVersionIdentifiersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceVersionIdentifiersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceVersionIdentifiersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceVersionIdentifiersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceVersionIdentifiersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceVersionIdentifiersValidationError) ErrorName() string {
	return "EndDeviceVersionIdentifiersValidationError"
}

// Error satisfies the builtin error interface
func (e EndDeviceVersionIdentifiersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceVersionIdentifiers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceVersionIdentifiersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceVersionIdentifiersValidationError{}

var _EndDeviceVersionIdentifiers_BrandID_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

var _EndDeviceVersionIdentifiers_ModelID_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// ValidateFields checks the field values on EndDeviceVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *EndDeviceVersion) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceVersionFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ids":

			if v, ok := interface{}(&m.EndDeviceVersionIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceVersionValidationError{
						field:  "ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "lorawan_version":

			if _, ok := MACVersion_name[int32(m.GetLoRaWANVersion())]; !ok {
				return EndDeviceVersionValidationError{
					field:  "lorawan_version",
					reason: "value must be one of the defined enum values",
				}
			}

		case "lorawan_phy_version":

			if _, ok := PHYVersion_name[int32(m.GetLoRaWANPHYVersion())]; !ok {
				return EndDeviceVersionValidationError{
					field:  "lorawan_phy_version",
					reason: "value must be one of the defined enum values",
				}
			}

		case "frequency_plan_id":

			if utf8.RuneCountInString(m.GetFrequencyPlanID()) > 64 {
				return EndDeviceVersionValidationError{
					field:  "frequency_plan_id",
					reason: "value length must be at most 64 runes",
				}
			}

		case "photos":

			if len(m.GetPhotos()) > 10 {
				return EndDeviceVersionValidationError{
					field:  "photos",
					reason: "value must contain no more than 10 item(s)",
				}
			}

		case "supports_class_b":
			// no validation rules for SupportsClassB
		case "supports_class_c":
			// no validation rules for SupportsClassC
		case "default_mac_settings":

			if v, ok := interface{}(m.GetDefaultMACSettings()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceVersionValidationError{
						field:  "default_mac_settings",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "min_frequency":
			// no validation rules for MinFrequency
		case "max_frequency":
			// no validation rules for MaxFrequency
		case "supports_join":
			// no validation rules for SupportsJoin
		case "resets_join_nonces":
			// no validation rules for ResetsJoinNonces
		case "default_formatters":

			if v, ok := interface{}(&m.DefaultFormatters).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceVersionValidationError{
						field:  "default_formatters",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return EndDeviceVersionValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceVersionValidationError is the validation error returned by
// EndDeviceVersion.ValidateFields if the designated constraints aren't met.
type EndDeviceVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceVersionValidationError) ErrorName() string { return "EndDeviceVersionValidationError" }

// Error satisfies the builtin error interface
func (e EndDeviceVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceVersionValidationError{}

// ValidateFields checks the field values on MACSettings with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *MACSettings) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACSettingsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "class_b_timeout":

			if v, ok := interface{}(m.GetClassBTimeout()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "class_b_timeout",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "ping_slot_periodicity":

			if v, ok := interface{}(m.GetPingSlotPeriodicity()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "ping_slot_periodicity",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "ping_slot_data_rate_index":

			if v, ok := interface{}(m.GetPingSlotDataRateIndex()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "ping_slot_data_rate_index",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "ping_slot_frequency":

			if v, ok := interface{}(m.GetPingSlotFrequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "ping_slot_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "beacon_frequency":

			if v, ok := interface{}(m.GetBeaconFrequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "beacon_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "class_c_timeout":

			if v, ok := interface{}(m.GetClassCTimeout()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "class_c_timeout",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx1_delay":

			if v, ok := interface{}(m.GetRx1Delay()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "rx1_delay",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx1_data_rate_offset":

			if v, ok := interface{}(m.GetRx1DataRateOffset()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "rx1_data_rate_offset",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx2_data_rate_index":

			if v, ok := interface{}(m.GetRx2DataRateIndex()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "rx2_data_rate_index",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx2_frequency":

			if v, ok := interface{}(m.GetRx2Frequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "rx2_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "factory_preset_frequencies":

			if len(m.GetFactoryPresetFrequencies()) > 96 {
				return MACSettingsValidationError{
					field:  "factory_preset_frequencies",
					reason: "value must contain no more than 96 item(s)",
				}
			}

		case "max_duty_cycle":

			if v, ok := interface{}(m.GetMaxDutyCycle()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "max_duty_cycle",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "supports_32_bit_f_cnt":

			if v, ok := interface{}(m.GetSupports32BitFCnt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "supports_32_bit_f_cnt",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "use_adr":

			if v, ok := interface{}(m.GetUseADR()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "use_adr",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "adr_margin":

			if v, ok := interface{}(m.GetADRMargin()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "adr_margin",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "resets_f_cnt":

			if v, ok := interface{}(m.GetResetsFCnt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "resets_f_cnt",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "status_time_periodicity":

			if v, ok := interface{}(m.GetStatusTimePeriodicity()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "status_time_periodicity",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "status_count_periodicity":

			if v, ok := interface{}(m.GetStatusCountPeriodicity()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "status_count_periodicity",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_rx1_delay":

			if v, ok := interface{}(m.GetDesiredRx1Delay()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_rx1_delay",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_rx1_data_rate_offset":

			if v, ok := interface{}(m.GetDesiredRx1DataRateOffset()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_rx1_data_rate_offset",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_rx2_data_rate_index":

			if v, ok := interface{}(m.GetDesiredRx2DataRateIndex()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_rx2_data_rate_index",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_rx2_frequency":

			if v, ok := interface{}(m.GetDesiredRx2Frequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_rx2_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_max_duty_cycle":

			if v, ok := interface{}(m.GetDesiredMaxDutyCycle()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_max_duty_cycle",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_adr_ack_limit_exponent":

			if v, ok := interface{}(m.GetDesiredADRAckLimitExponent()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_adr_ack_limit_exponent",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_adr_ack_delay_exponent":

			if v, ok := interface{}(m.GetDesiredADRAckDelayExponent()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_adr_ack_delay_exponent",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_ping_slot_data_rate_index":

			if v, ok := interface{}(m.GetDesiredPingSlotDataRateIndex()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_ping_slot_data_rate_index",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_ping_slot_frequency":

			if v, ok := interface{}(m.GetDesiredPingSlotFrequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_ping_slot_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_beacon_frequency":

			if v, ok := interface{}(m.GetDesiredBeaconFrequency()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACSettingsValidationError{
						field:  "desired_beacon_frequency",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return MACSettingsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACSettingsValidationError is the validation error returned by
// MACSettings.ValidateFields if the designated constraints aren't met.
type MACSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACSettingsValidationError) ErrorName() string { return "MACSettingsValidationError" }

// Error satisfies the builtin error interface
func (e MACSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACSettingsValidationError{}

// ValidateFields checks the field values on MACState with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *MACState) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACStateFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "current_parameters":

			if v, ok := interface{}(&m.CurrentParameters).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "current_parameters",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "desired_parameters":

			if v, ok := interface{}(&m.DesiredParameters).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "desired_parameters",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "device_class":

			if _, ok := Class_name[int32(m.GetDeviceClass())]; !ok {
				return MACStateValidationError{
					field:  "device_class",
					reason: "value must be one of the defined enum values",
				}
			}

		case "lorawan_version":

			if _, ok := MACVersion_name[int32(m.GetLoRaWANVersion())]; !ok {
				return MACStateValidationError{
					field:  "lorawan_version",
					reason: "value must be one of the defined enum values",
				}
			}

		case "last_confirmed_downlink_at":

			if v, ok := interface{}(m.GetLastConfirmedDownlinkAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "last_confirmed_downlink_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "last_dev_status_f_cnt_up":
			// no validation rules for LastDevStatusFCntUp
		case "ping_slot_periodicity":

			if v, ok := interface{}(m.GetPingSlotPeriodicity()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "ping_slot_periodicity",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "pending_application_downlink":

			if v, ok := interface{}(m.GetPendingApplicationDownlink()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "pending_application_downlink",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "queued_responses":

			for idx, item := range m.GetQueuedResponses() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACStateValidationError{
							field:  fmt.Sprintf("queued_responses[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "pending_requests":

			for idx, item := range m.GetPendingRequests() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACStateValidationError{
							field:  fmt.Sprintf("pending_requests[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "queued_join_accept":

			if v, ok := interface{}(m.GetQueuedJoinAccept()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "queued_join_accept",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "pending_join_request":

			if v, ok := interface{}(m.GetPendingJoinRequest()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "pending_join_request",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx_windows_available":
			// no validation rules for RxWindowsAvailable
		case "recent_uplinks":

			for idx, item := range m.GetRecentUplinks() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACStateValidationError{
							field:  fmt.Sprintf("recent_uplinks[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "recent_downlinks":

			for idx, item := range m.GetRecentDownlinks() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACStateValidationError{
							field:  fmt.Sprintf("recent_downlinks[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "last_network_initiated_downlink_at":

			if v, ok := interface{}(m.GetLastNetworkInitiatedDownlinkAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "last_network_initiated_downlink_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rejected_adr_data_rate_indexes":

			if len(m.GetRejectedADRDataRateIndexes()) > 15 {
				return MACStateValidationError{
					field:  "rejected_adr_data_rate_indexes",
					reason: "value must contain no more than 15 item(s)",
				}
			}

			for idx, item := range m.GetRejectedADRDataRateIndexes() {
				_, _ = idx, item

				if _, ok := DataRateIndex_name[int32(item)]; !ok {
					return MACStateValidationError{
						field:  fmt.Sprintf("rejected_adr_data_rate_indexes[%v]", idx),
						reason: "value must be one of the defined enum values",
					}
				}

			}

		case "rejected_adr_tx_power_indexes":

			if len(m.GetRejectedADRTxPowerIndexes()) > 15 {
				return MACStateValidationError{
					field:  "rejected_adr_tx_power_indexes",
					reason: "value must contain no more than 15 item(s)",
				}
			}

			for idx, item := range m.GetRejectedADRTxPowerIndexes() {
				_, _ = idx, item

				if item > 15 {
					return MACStateValidationError{
						field:  fmt.Sprintf("rejected_adr_tx_power_indexes[%v]", idx),
						reason: "value must be less than or equal to 15",
					}
				}

			}

		case "rejected_frequencies":

			for idx, item := range m.GetRejectedFrequencies() {
				_, _ = idx, item

				if item < 100000 {
					return MACStateValidationError{
						field:  fmt.Sprintf("rejected_frequencies[%v]", idx),
						reason: "value must be greater than or equal to 100000",
					}
				}

			}

		case "last_downlink_at":

			if v, ok := interface{}(m.GetLastDownlinkAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACStateValidationError{
						field:  "last_downlink_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rejected_data_rate_ranges":

			for key, val := range m.GetRejectedDataRateRanges() {
				_ = val

				// no validation rules for RejectedDataRateRanges[key]

				if v, ok := interface{}(val).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACStateValidationError{
							field:  fmt.Sprintf("rejected_data_rate_ranges[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "last_adr_change_f_cnt_up":
			// no validation rules for LastADRChangeFCntUp
		default:
			return MACStateValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACStateValidationError is the validation error returned by
// MACState.ValidateFields if the designated constraints aren't met.
type MACStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACStateValidationError) ErrorName() string { return "MACStateValidationError" }

// Error satisfies the builtin error interface
func (e MACStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACStateValidationError{}

// ValidateFields checks the field values on EndDeviceAuthenticationCode with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *EndDeviceAuthenticationCode) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceAuthenticationCodeFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "value":

			if !_EndDeviceAuthenticationCode_Value_Pattern.MatchString(m.GetValue()) {
				return EndDeviceAuthenticationCodeValidationError{
					field:  "value",
					reason: "value does not match regex pattern \"^[A-Z0-9]{1,32}$\"",
				}
			}

		case "valid_from":

			if v, ok := interface{}(m.GetValidFrom()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceAuthenticationCodeValidationError{
						field:  "valid_from",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "valid_to":

			if v, ok := interface{}(m.GetValidTo()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceAuthenticationCodeValidationError{
						field:  "valid_to",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return EndDeviceAuthenticationCodeValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceAuthenticationCodeValidationError is the validation error returned
// by EndDeviceAuthenticationCode.ValidateFields if the designated constraints
// aren't met.
type EndDeviceAuthenticationCodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceAuthenticationCodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceAuthenticationCodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceAuthenticationCodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceAuthenticationCodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceAuthenticationCodeValidationError) ErrorName() string {
	return "EndDeviceAuthenticationCodeValidationError"
}

// Error satisfies the builtin error interface
func (e EndDeviceAuthenticationCodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceAuthenticationCode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceAuthenticationCodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceAuthenticationCodeValidationError{}

var _EndDeviceAuthenticationCode_Value_Pattern = regexp.MustCompile("^[A-Z0-9]{1,32}$")

// ValidateFields checks the field values on EndDevice with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *EndDevice) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ids":

			if v, ok := interface{}(&m.EndDeviceIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "created_at":

			if v, ok := interface{}(&m.CreatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "updated_at":

			if v, ok := interface{}(&m.UpdatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "name":

			if utf8.RuneCountInString(m.GetName()) > 50 {
				return EndDeviceValidationError{
					field:  "name",
					reason: "value length must be at most 50 runes",
				}
			}

		case "description":

			if utf8.RuneCountInString(m.GetDescription()) > 2000 {
				return EndDeviceValidationError{
					field:  "description",
					reason: "value length must be at most 2000 runes",
				}
			}

		case "attributes":

			if len(m.GetAttributes()) > 10 {
				return EndDeviceValidationError{
					field:  "attributes",
					reason: "value must contain no more than 10 pair(s)",
				}
			}

			for key, val := range m.GetAttributes() {
				_ = val

				if utf8.RuneCountInString(key) > 36 {
					return EndDeviceValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value length must be at most 36 runes",
					}
				}

				if !_EndDevice_Attributes_Pattern.MatchString(key) {
					return EndDeviceValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

				if utf8.RuneCountInString(val) > 200 {
					return EndDeviceValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value length must be at most 200 runes",
					}
				}

			}

		case "version_ids":

			if v, ok := interface{}(m.GetVersionIDs()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "version_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "service_profile_id":

			if utf8.RuneCountInString(m.GetServiceProfileID()) > 64 {
				return EndDeviceValidationError{
					field:  "service_profile_id",
					reason: "value length must be at most 64 runes",
				}
			}

		case "network_server_address":

			if !_EndDevice_NetworkServerAddress_Pattern.MatchString(m.GetNetworkServerAddress()) {
				return EndDeviceValidationError{
					field:  "network_server_address",
					reason: "value does not match regex pattern \"^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$\"",
				}
			}

		case "network_server_kek_label":

			if utf8.RuneCountInString(m.GetNetworkServerKEKLabel()) > 2048 {
				return EndDeviceValidationError{
					field:  "network_server_kek_label",
					reason: "value length must be at most 2048 runes",
				}
			}

		case "application_server_address":

			if !_EndDevice_ApplicationServerAddress_Pattern.MatchString(m.GetApplicationServerAddress()) {
				return EndDeviceValidationError{
					field:  "application_server_address",
					reason: "value does not match regex pattern \"^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$\"",
				}
			}

		case "application_server_kek_label":

			if utf8.RuneCountInString(m.GetApplicationServerKEKLabel()) > 2048 {
				return EndDeviceValidationError{
					field:  "application_server_kek_label",
					reason: "value length must be at most 2048 runes",
				}
			}

		case "application_server_id":

			if utf8.RuneCountInString(m.GetApplicationServerID()) > 100 {
				return EndDeviceValidationError{
					field:  "application_server_id",
					reason: "value length must be at most 100 runes",
				}
			}

		case "join_server_address":

			if !_EndDevice_JoinServerAddress_Pattern.MatchString(m.GetJoinServerAddress()) {
				return EndDeviceValidationError{
					field:  "join_server_address",
					reason: "value does not match regex pattern \"^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$\"",
				}
			}

		case "locations":

			for key, val := range m.GetLocations() {
				_ = val

				if utf8.RuneCountInString(key) > 36 {
					return EndDeviceValidationError{
						field:  fmt.Sprintf("locations[%v]", key),
						reason: "value length must be at most 36 runes",
					}
				}

				if !_EndDevice_Locations_Pattern.MatchString(key) {
					return EndDeviceValidationError{
						field:  fmt.Sprintf("locations[%v]", key),
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

				if v, ok := interface{}(val).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return EndDeviceValidationError{
							field:  fmt.Sprintf("locations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "picture":

			if v, ok := interface{}(m.GetPicture()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "picture",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "supports_class_b":
			// no validation rules for SupportsClassB
		case "supports_class_c":
			// no validation rules for SupportsClassC
		case "lorawan_version":

			if _, ok := MACVersion_name[int32(m.GetLoRaWANVersion())]; !ok {
				return EndDeviceValidationError{
					field:  "lorawan_version",
					reason: "value must be one of the defined enum values",
				}
			}

		case "lorawan_phy_version":

			if _, ok := PHYVersion_name[int32(m.GetLoRaWANPHYVersion())]; !ok {
				return EndDeviceValidationError{
					field:  "lorawan_phy_version",
					reason: "value must be one of the defined enum values",
				}
			}

		case "frequency_plan_id":

			if utf8.RuneCountInString(m.GetFrequencyPlanID()) > 64 {
				return EndDeviceValidationError{
					field:  "frequency_plan_id",
					reason: "value length must be at most 64 runes",
				}
			}

		case "min_frequency":
			// no validation rules for MinFrequency
		case "max_frequency":
			// no validation rules for MaxFrequency
		case "supports_join":
			// no validation rules for SupportsJoin
		case "resets_join_nonces":
			// no validation rules for ResetsJoinNonces
		case "root_keys":

			if v, ok := interface{}(m.GetRootKeys()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "root_keys",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "net_id":
			// no validation rules for NetID
		case "mac_settings":

			if v, ok := interface{}(m.GetMACSettings()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "mac_settings",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "mac_state":

			if v, ok := interface{}(m.GetMACState()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "mac_state",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "pending_mac_state":

			if v, ok := interface{}(m.GetPendingMACState()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "pending_mac_state",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "session":

			if v, ok := interface{}(m.GetSession()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "session",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "pending_session":

			if v, ok := interface{}(m.GetPendingSession()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "pending_session",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "last_dev_nonce":
			// no validation rules for LastDevNonce
		case "used_dev_nonces":

		case "last_join_nonce":
			// no validation rules for LastJoinNonce
		case "last_rj_count_0":
			// no validation rules for LastRJCount0
		case "last_rj_count_1":
			// no validation rules for LastRJCount1
		case "last_dev_status_received_at":

			if v, ok := interface{}(m.GetLastDevStatusReceivedAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "last_dev_status_received_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "power_state":

			if _, ok := PowerState_name[int32(m.GetPowerState())]; !ok {
				return EndDeviceValidationError{
					field:  "power_state",
					reason: "value must be one of the defined enum values",
				}
			}

		case "battery_percentage":

			if wrapper := m.GetBatteryPercentage(); wrapper != nil {

				if val := wrapper.GetValue(); val < 0 || val > 1 {
					return EndDeviceValidationError{
						field:  "battery_percentage",
						reason: "value must be inside range [0, 1]",
					}
				}

			}

		case "downlink_margin":
			// no validation rules for DownlinkMargin
		case "queued_application_downlinks":

			for idx, item := range m.GetQueuedApplicationDownlinks() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return EndDeviceValidationError{
							field:  fmt.Sprintf("queued_application_downlinks[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "formatters":

			if v, ok := interface{}(m.GetFormatters()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "formatters",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "provisioner_id":

			if utf8.RuneCountInString(m.GetProvisionerID()) > 36 {
				return EndDeviceValidationError{
					field:  "provisioner_id",
					reason: "value length must be at most 36 runes",
				}
			}

			if !_EndDevice_ProvisionerID_Pattern.MatchString(m.GetProvisionerID()) {
				return EndDeviceValidationError{
					field:  "provisioner_id",
					reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$|^$\"",
				}
			}

		case "provisioning_data":

			if v, ok := interface{}(m.GetProvisioningData()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "provisioning_data",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "multicast":
			// no validation rules for Multicast
		case "claim_authentication_code":

			if v, ok := interface{}(m.GetClaimAuthenticationCode()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "claim_authentication_code",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "skip_payload_crypto":
			// no validation rules for SkipPayloadCrypto
		case "skip_payload_crypto_override":

			if v, ok := interface{}(m.GetSkipPayloadCryptoOverride()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceValidationError{
						field:  "skip_payload_crypto_override",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return EndDeviceValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceValidationError is the validation error returned by
// EndDevice.ValidateFields if the designated constraints aren't met.
type EndDeviceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceValidationError) ErrorName() string { return "EndDeviceValidationError" }

// Error satisfies the builtin error interface
func (e EndDeviceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDevice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceValidationError{}

var _EndDevice_Attributes_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

var _EndDevice_NetworkServerAddress_Pattern = regexp.MustCompile("^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$")

var _EndDevice_ApplicationServerAddress_Pattern = regexp.MustCompile("^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$")

var _EndDevice_JoinServerAddress_Pattern = regexp.MustCompile("^(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*(?:[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])(?::[0-9]{1,5})?$|^$")

var _EndDevice_Locations_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

var _EndDevice_ProvisionerID_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$|^$")

// ValidateFields checks the field values on EndDevices with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *EndDevices) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDevicesFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_devices":

			for idx, item := range m.GetEndDevices() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return EndDevicesValidationError{
							field:  fmt.Sprintf("end_devices[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return EndDevicesValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDevicesValidationError is the validation error returned by
// EndDevices.ValidateFields if the designated constraints aren't met.
type EndDevicesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDevicesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDevicesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDevicesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDevicesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDevicesValidationError) ErrorName() string { return "EndDevicesValidationError" }

// Error satisfies the builtin error interface
func (e EndDevicesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDevices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDevicesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDevicesValidationError{}

// ValidateFields checks the field values on DevAddrPrefix with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *DevAddrPrefix) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = DevAddrPrefixFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "dev_addr":
			// no validation rules for DevAddr
		case "length":
			// no validation rules for Length
		default:
			return DevAddrPrefixValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// DevAddrPrefixValidationError is the validation error returned by
// DevAddrPrefix.ValidateFields if the designated constraints aren't met.
type DevAddrPrefixValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DevAddrPrefixValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DevAddrPrefixValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DevAddrPrefixValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DevAddrPrefixValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DevAddrPrefixValidationError) ErrorName() string { return "DevAddrPrefixValidationError" }

// Error satisfies the builtin error interface
func (e DevAddrPrefixValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDevAddrPrefix.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DevAddrPrefixValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DevAddrPrefixValidationError{}

// ValidateFields checks the field values on CreateEndDeviceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateEndDeviceRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = CreateEndDeviceRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device":

			if v, ok := interface{}(&m.EndDevice).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateEndDeviceRequestValidationError{
						field:  "end_device",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return CreateEndDeviceRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// CreateEndDeviceRequestValidationError is the validation error returned by
// CreateEndDeviceRequest.ValidateFields if the designated constraints aren't met.
type CreateEndDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEndDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEndDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEndDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEndDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEndDeviceRequestValidationError) ErrorName() string {
	return "CreateEndDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateEndDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEndDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEndDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEndDeviceRequestValidationError{}

// ValidateFields checks the field values on UpdateEndDeviceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateEndDeviceRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UpdateEndDeviceRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device":

			if v, ok := interface{}(&m.EndDevice).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateEndDeviceRequestValidationError{
						field:  "end_device",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateEndDeviceRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UpdateEndDeviceRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UpdateEndDeviceRequestValidationError is the validation error returned by
// UpdateEndDeviceRequest.ValidateFields if the designated constraints aren't met.
type UpdateEndDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateEndDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateEndDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateEndDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateEndDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateEndDeviceRequestValidationError) ErrorName() string {
	return "UpdateEndDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateEndDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateEndDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateEndDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateEndDeviceRequestValidationError{}

// ValidateFields checks the field values on GetEndDeviceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetEndDeviceRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetEndDeviceRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device_ids":

			if v, ok := interface{}(&m.EndDeviceIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetEndDeviceRequestValidationError{
						field:  "end_device_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetEndDeviceRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return GetEndDeviceRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetEndDeviceRequestValidationError is the validation error returned by
// GetEndDeviceRequest.ValidateFields if the designated constraints aren't met.
type GetEndDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEndDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEndDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEndDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEndDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEndDeviceRequestValidationError) ErrorName() string {
	return "GetEndDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEndDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEndDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEndDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEndDeviceRequestValidationError{}

// ValidateFields checks the field values on
// GetEndDeviceIdentifiersForEUIsRequest with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *GetEndDeviceIdentifiersForEUIsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetEndDeviceIdentifiersForEUIsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "join_eui":
			// no validation rules for JoinEUI
		case "dev_eui":
			// no validation rules for DevEUI
		default:
			return GetEndDeviceIdentifiersForEUIsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetEndDeviceIdentifiersForEUIsRequestValidationError is the validation error
// returned by GetEndDeviceIdentifiersForEUIsRequest.ValidateFields if the
// designated constraints aren't met.
type GetEndDeviceIdentifiersForEUIsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) ErrorName() string {
	return "GetEndDeviceIdentifiersForEUIsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEndDeviceIdentifiersForEUIsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEndDeviceIdentifiersForEUIsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEndDeviceIdentifiersForEUIsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEndDeviceIdentifiersForEUIsRequestValidationError{}

// ValidateFields checks the field values on ListEndDevicesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListEndDevicesRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ListEndDevicesRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "application_ids":

			if v, ok := interface{}(&m.ApplicationIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ListEndDevicesRequestValidationError{
						field:  "application_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ListEndDevicesRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "order":

			if _, ok := _ListEndDevicesRequest_Order_InLookup[m.GetOrder()]; !ok {
				return ListEndDevicesRequestValidationError{
					field:  "order",
					reason: "value must be in list [ device_id -device_id join_eui -join_eui dev_eui -dev_eui name -name description -description created_at -created_at]",
				}
			}

		case "limit":

			if m.GetLimit() > 1000 {
				return ListEndDevicesRequestValidationError{
					field:  "limit",
					reason: "value must be less than or equal to 1000",
				}
			}

		case "page":
			// no validation rules for Page
		default:
			return ListEndDevicesRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ListEndDevicesRequestValidationError is the validation error returned by
// ListEndDevicesRequest.ValidateFields if the designated constraints aren't met.
type ListEndDevicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEndDevicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEndDevicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEndDevicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEndDevicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEndDevicesRequestValidationError) ErrorName() string {
	return "ListEndDevicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListEndDevicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEndDevicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEndDevicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEndDevicesRequestValidationError{}

var _ListEndDevicesRequest_Order_InLookup = map[string]struct{}{
	"":             {},
	"device_id":    {},
	"-device_id":   {},
	"join_eui":     {},
	"-join_eui":    {},
	"dev_eui":      {},
	"-dev_eui":     {},
	"name":         {},
	"-name":        {},
	"description":  {},
	"-description": {},
	"created_at":   {},
	"-created_at":  {},
}

// ValidateFields checks the field values on SetEndDeviceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SetEndDeviceRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SetEndDeviceRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device":

			if v, ok := interface{}(&m.EndDevice).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SetEndDeviceRequestValidationError{
						field:  "end_device",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SetEndDeviceRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return SetEndDeviceRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// SetEndDeviceRequestValidationError is the validation error returned by
// SetEndDeviceRequest.ValidateFields if the designated constraints aren't met.
type SetEndDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetEndDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetEndDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetEndDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetEndDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetEndDeviceRequestValidationError) ErrorName() string {
	return "SetEndDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetEndDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetEndDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetEndDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetEndDeviceRequestValidationError{}

// ValidateFields checks the field values on ResetAndGetEndDeviceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *ResetAndGetEndDeviceRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ResetAndGetEndDeviceRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device_ids":

			if v, ok := interface{}(&m.EndDeviceIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ResetAndGetEndDeviceRequestValidationError{
						field:  "end_device_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ResetAndGetEndDeviceRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return ResetAndGetEndDeviceRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ResetAndGetEndDeviceRequestValidationError is the validation error returned
// by ResetAndGetEndDeviceRequest.ValidateFields if the designated constraints
// aren't met.
type ResetAndGetEndDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetAndGetEndDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetAndGetEndDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetAndGetEndDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetAndGetEndDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetAndGetEndDeviceRequestValidationError) ErrorName() string {
	return "ResetAndGetEndDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResetAndGetEndDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetAndGetEndDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetAndGetEndDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetAndGetEndDeviceRequestValidationError{}

// ValidateFields checks the field values on EndDeviceTemplate with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *EndDeviceTemplate) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceTemplateFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "end_device":

			if v, ok := interface{}(&m.EndDevice).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceTemplateValidationError{
						field:  "end_device",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return EndDeviceTemplateValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "mapping_key":

			if utf8.RuneCountInString(m.GetMappingKey()) > 100 {
				return EndDeviceTemplateValidationError{
					field:  "mapping_key",
					reason: "value length must be at most 100 runes",
				}
			}

		default:
			return EndDeviceTemplateValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceTemplateValidationError is the validation error returned by
// EndDeviceTemplate.ValidateFields if the designated constraints aren't met.
type EndDeviceTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceTemplateValidationError) ErrorName() string {
	return "EndDeviceTemplateValidationError"
}

// Error satisfies the builtin error interface
func (e EndDeviceTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceTemplateValidationError{}

// ValidateFields checks the field values on EndDeviceTemplateFormat with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *EndDeviceTemplateFormat) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceTemplateFormatFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "name":

			if utf8.RuneCountInString(m.GetName()) > 100 {
				return EndDeviceTemplateFormatValidationError{
					field:  "name",
					reason: "value length must be at most 100 runes",
				}
			}

		case "description":

			if utf8.RuneCountInString(m.GetDescription()) > 200 {
				return EndDeviceTemplateFormatValidationError{
					field:  "description",
					reason: "value length must be at most 200 runes",
				}
			}

		case "file_extensions":

			if len(m.GetFileExtensions()) > 100 {
				return EndDeviceTemplateFormatValidationError{
					field:  "file_extensions",
					reason: "value must contain no more than 100 item(s)",
				}
			}

			_EndDeviceTemplateFormat_FileExtensions_Unique := make(map[string]struct{}, len(m.GetFileExtensions()))

			for idx, item := range m.GetFileExtensions() {
				_, _ = idx, item

				if _, exists := _EndDeviceTemplateFormat_FileExtensions_Unique[item]; exists {
					return EndDeviceTemplateFormatValidationError{
						field:  fmt.Sprintf("file_extensions[%v]", idx),
						reason: "repeated value must contain unique items",
					}
				} else {
					_EndDeviceTemplateFormat_FileExtensions_Unique[item] = struct{}{}
				}

				if !_EndDeviceTemplateFormat_FileExtensions_Pattern.MatchString(item) {
					return EndDeviceTemplateFormatValidationError{
						field:  fmt.Sprintf("file_extensions[%v]", idx),
						reason: "value does not match regex pattern \"^(?:\\\\.[a-z0-9]{1,16}){1,2}$\"",
					}
				}

			}

		default:
			return EndDeviceTemplateFormatValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceTemplateFormatValidationError is the validation error returned by
// EndDeviceTemplateFormat.ValidateFields if the designated constraints aren't met.
type EndDeviceTemplateFormatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceTemplateFormatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceTemplateFormatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceTemplateFormatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceTemplateFormatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceTemplateFormatValidationError) ErrorName() string {
	return "EndDeviceTemplateFormatValidationError"
}

// Error satisfies the builtin error interface
func (e EndDeviceTemplateFormatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceTemplateFormat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceTemplateFormatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceTemplateFormatValidationError{}

var _EndDeviceTemplateFormat_FileExtensions_Pattern = regexp.MustCompile("^(?:\\.[a-z0-9]{1,16}){1,2}$")

// ValidateFields checks the field values on EndDeviceTemplateFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *EndDeviceTemplateFormats) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = EndDeviceTemplateFormatsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "formats":

			for key, val := range m.GetFormats() {
				_ = val

				if utf8.RuneCountInString(key) > 36 {
					return EndDeviceTemplateFormatsValidationError{
						field:  fmt.Sprintf("formats[%v]", key),
						reason: "value length must be at most 36 runes",
					}
				}

				if !_EndDeviceTemplateFormats_Formats_Pattern.MatchString(key) {
					return EndDeviceTemplateFormatsValidationError{
						field:  fmt.Sprintf("formats[%v]", key),
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

				if v, ok := interface{}(val).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return EndDeviceTemplateFormatsValidationError{
							field:  fmt.Sprintf("formats[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return EndDeviceTemplateFormatsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// EndDeviceTemplateFormatsValidationError is the validation error returned by
// EndDeviceTemplateFormats.ValidateFields if the designated constraints
// aren't met.
type EndDeviceTemplateFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndDeviceTemplateFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndDeviceTemplateFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndDeviceTemplateFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndDeviceTemplateFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndDeviceTemplateFormatsValidationError) ErrorName() string {
	return "EndDeviceTemplateFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e EndDeviceTemplateFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndDeviceTemplateFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndDeviceTemplateFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndDeviceTemplateFormatsValidationError{}

var _EndDeviceTemplateFormats_Formats_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// ValidateFields checks the field values on ConvertEndDeviceTemplateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *ConvertEndDeviceTemplateRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ConvertEndDeviceTemplateRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "format_id":

			if utf8.RuneCountInString(m.GetFormatID()) > 36 {
				return ConvertEndDeviceTemplateRequestValidationError{
					field:  "format_id",
					reason: "value length must be at most 36 runes",
				}
			}

			if !_ConvertEndDeviceTemplateRequest_FormatID_Pattern.MatchString(m.GetFormatID()) {
				return ConvertEndDeviceTemplateRequestValidationError{
					field:  "format_id",
					reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
				}
			}

		case "data":
			// no validation rules for Data
		default:
			return ConvertEndDeviceTemplateRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ConvertEndDeviceTemplateRequestValidationError is the validation error
// returned by ConvertEndDeviceTemplateRequest.ValidateFields if the
// designated constraints aren't met.
type ConvertEndDeviceTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConvertEndDeviceTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConvertEndDeviceTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConvertEndDeviceTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConvertEndDeviceTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConvertEndDeviceTemplateRequestValidationError) ErrorName() string {
	return "ConvertEndDeviceTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConvertEndDeviceTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConvertEndDeviceTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConvertEndDeviceTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConvertEndDeviceTemplateRequestValidationError{}

var _ConvertEndDeviceTemplateRequest_FormatID_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// ValidateFields checks the field values on MACParameters_Channel with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACParameters_Channel) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACParameters_ChannelFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "uplink_frequency":

			if val := m.GetUplinkFrequency(); val > 0 && val < 100000 {
				return MACParameters_ChannelValidationError{
					field:  "uplink_frequency",
					reason: "value must be outside range (0, 100000)",
				}
			}

		case "downlink_frequency":

			if m.GetDownlinkFrequency() < 100000 {
				return MACParameters_ChannelValidationError{
					field:  "downlink_frequency",
					reason: "value must be greater than or equal to 100000",
				}
			}

		case "min_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetMinDataRateIndex())]; !ok {
				return MACParameters_ChannelValidationError{
					field:  "min_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		case "max_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetMaxDataRateIndex())]; !ok {
				return MACParameters_ChannelValidationError{
					field:  "max_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		case "enable_uplink":
			// no validation rules for EnableUplink
		default:
			return MACParameters_ChannelValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACParameters_ChannelValidationError is the validation error returned by
// MACParameters_Channel.ValidateFields if the designated constraints aren't met.
type MACParameters_ChannelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACParameters_ChannelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACParameters_ChannelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACParameters_ChannelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACParameters_ChannelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACParameters_ChannelValidationError) ErrorName() string {
	return "MACParameters_ChannelValidationError"
}

// Error satisfies the builtin error interface
func (e MACParameters_ChannelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACParameters_Channel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACParameters_ChannelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACParameters_ChannelValidationError{}

// ValidateFields checks the field values on MACState_JoinRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACState_JoinRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACState_JoinRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "downlink_settings":

			if v, ok := interface{}(&m.DownlinkSettings).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACState_JoinRequestValidationError{
						field:  "downlink_settings",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "rx_delay":

			if _, ok := RxDelay_name[int32(m.GetRxDelay())]; !ok {
				return MACState_JoinRequestValidationError{
					field:  "rx_delay",
					reason: "value must be one of the defined enum values",
				}
			}

		case "cf_list":

			if v, ok := interface{}(m.GetCFList()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACState_JoinRequestValidationError{
						field:  "cf_list",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return MACState_JoinRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACState_JoinRequestValidationError is the validation error returned by
// MACState_JoinRequest.ValidateFields if the designated constraints aren't met.
type MACState_JoinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACState_JoinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACState_JoinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACState_JoinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACState_JoinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACState_JoinRequestValidationError) ErrorName() string {
	return "MACState_JoinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MACState_JoinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACState_JoinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACState_JoinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACState_JoinRequestValidationError{}

// ValidateFields checks the field values on MACState_JoinAccept with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACState_JoinAccept) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACState_JoinAcceptFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "payload":

			if l := len(m.GetPayload()); l < 17 || l > 33 {
				return MACState_JoinAcceptValidationError{
					field:  "payload",
					reason: "value length must be between 17 and 33 bytes, inclusive",
				}
			}

		case "request":

			if v, ok := interface{}(&m.Request).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACState_JoinAcceptValidationError{
						field:  "request",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "keys":

			if v, ok := interface{}(&m.Keys).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return MACState_JoinAcceptValidationError{
						field:  "keys",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "correlation_ids":

			for idx, item := range m.GetCorrelationIDs() {
				_, _ = idx, item

				if utf8.RuneCountInString(item) > 100 {
					return MACState_JoinAcceptValidationError{
						field:  fmt.Sprintf("correlation_ids[%v]", idx),
						reason: "value length must be at most 100 runes",
					}
				}

			}

		case "dev_addr":
			// no validation rules for DevAddr
		case "net_id":
			// no validation rules for NetID
		default:
			return MACState_JoinAcceptValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACState_JoinAcceptValidationError is the validation error returned by
// MACState_JoinAccept.ValidateFields if the designated constraints aren't met.
type MACState_JoinAcceptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACState_JoinAcceptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACState_JoinAcceptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACState_JoinAcceptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACState_JoinAcceptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACState_JoinAcceptValidationError) ErrorName() string {
	return "MACState_JoinAcceptValidationError"
}

// Error satisfies the builtin error interface
func (e MACState_JoinAcceptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACState_JoinAccept.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACState_JoinAcceptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACState_JoinAcceptValidationError{}

// ValidateFields checks the field values on MACState_DataRateRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACState_DataRateRange) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACState_DataRateRangeFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "min_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetMinDataRateIndex())]; !ok {
				return MACState_DataRateRangeValidationError{
					field:  "min_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		case "max_data_rate_index":

			if _, ok := DataRateIndex_name[int32(m.GetMaxDataRateIndex())]; !ok {
				return MACState_DataRateRangeValidationError{
					field:  "max_data_rate_index",
					reason: "value must be one of the defined enum values",
				}
			}

		default:
			return MACState_DataRateRangeValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACState_DataRateRangeValidationError is the validation error returned by
// MACState_DataRateRange.ValidateFields if the designated constraints aren't met.
type MACState_DataRateRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACState_DataRateRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACState_DataRateRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACState_DataRateRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACState_DataRateRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACState_DataRateRangeValidationError) ErrorName() string {
	return "MACState_DataRateRangeValidationError"
}

// Error satisfies the builtin error interface
func (e MACState_DataRateRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACState_DataRateRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACState_DataRateRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACState_DataRateRangeValidationError{}

// ValidateFields checks the field values on MACState_DataRateRanges with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MACState_DataRateRanges) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = MACState_DataRateRangesFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ranges":

			if len(m.GetRanges()) < 1 {
				return MACState_DataRateRangesValidationError{
					field:  "ranges",
					reason: "value must contain at least 1 item(s)",
				}
			}

			for idx, item := range m.GetRanges() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return MACState_DataRateRangesValidationError{
							field:  fmt.Sprintf("ranges[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return MACState_DataRateRangesValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// MACState_DataRateRangesValidationError is the validation error returned by
// MACState_DataRateRanges.ValidateFields if the designated constraints aren't met.
type MACState_DataRateRangesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MACState_DataRateRangesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MACState_DataRateRangesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MACState_DataRateRangesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MACState_DataRateRangesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MACState_DataRateRangesValidationError) ErrorName() string {
	return "MACState_DataRateRangesValidationError"
}

// Error satisfies the builtin error interface
func (e MACState_DataRateRangesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMACState_DataRateRanges.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MACState_DataRateRangesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MACState_DataRateRangesValidationError{}
